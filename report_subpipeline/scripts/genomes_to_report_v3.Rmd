---
title: "`r batch_title`"
subtitle: "Assemblycomparator2 Report"
date: "`r Sys.time()`"
output:
  html_document:
    toc: true
    toc_depth: 2
  #prettydoc::html_pretty:
    theme: readable
    #highlight: github
editor_options: 
  chunk_output_type: console
#css: "max-width: 5000px; margin: auto; padding: 1em; line-height: 20px"
---



```{r dependencies, echo=F, message=F, warning=F}

# Dependencies

library(tidyverse)
library(DT)
library(ape)
#library(prettydoc)
#library(phytools)
#library(phangorn)


```



#### Temporary debug information
```{r debug, echo=F, message=F, warning=F, error = F}



# DEBUG setup for vscode on KTFL running R on ssh to saga
debug = F
if (debug) {
    base_variable = "~/axodines/assemblycomparator2"
    results_directory = "results_ac2"
    batch_title = "MAGs"
    setwd("~/axodines/assemblycomparator2/tests/MAGs")
}

#results_directory = "~/axodines/assemblycomparator2/tests/MAGs/results_ac2" # debug
#setwd("~/axodines/assemblycomparator2/report_subpipeline/scripts")



tribble(
    ~name,                  ~value,
    "base_variable",        base_variable,
    "results_directory",    results_directory,
    "batch_title",          batch_title,
)
```


`r paste("This report was generated using the results located at", results_directory)`


```{r global-setup, echo=F, message=F, warning=F}


## Global variables
#base_variable = "~/assemblycomparator2/" # I need to find a way of pulling this out of thin air. Maybe there's a way of passing commands through the render call, or I can
report_scripts = paste0(base_variable, "/report_subpipeline/scripts/")




## Global functions

# Print Quick
pq = function(logical, input) {
    if (logical) {
        paste(input)
    } 
}

# A function that returns a new global table enumerator for each call
tableno_var = 0
tableno = function() {
    tableno_var <<- tableno_var + 1
    tableno_var
}

# Same, but for figures
figno_var = 0
figno = function() {
    figno_var <<- figno_var + 1
    figno_var
}


dtable = function(X) {
    
    datatable(X,
        extensions = c("Buttons","KeyTable"), 
        options = list(
            dom = '<"top"B>frtip',
            buttons = list('csv', 'excel'),
            keys = T
        ),
        rownames=F
    )
}

create_dt <- function(x){
    DT::datatable(x,
        extensions = 'Buttons',
        options = list(
            dom = 'Blfrtip',
            buttons = c('copy', 'csv', 'excel'),
            lengthMenu = list(
                c(10,25,50,-1),
                c(10,25,50,
                "All")
            )
        )
    )
}

custom_dt = function(x, filename = "viewer_", dom = "Blfrtip", ordering = T) {
    DT::datatable(
        x,
        options = list(
            dom = dom,
            ordering = ordering,
            #buttons = c('copy', 'csv', 'excel')
            buttons = list(
                'copy',
                list(extend = "csv", filename = filename),
                list(extend = "excel", filename = filename)
            )
        ),
        rownames = F,
        extensions = 'Buttons',
    )
}

```



## Sample overview

```{r sample-overview, echo=FALSE, message=F, warning=F}

# Import the metadata table
# This table makes it easy for us later to convert the long paths to short and simple sample names
metadata_file = paste0(results_directory, "/metadata.tsv")

if (file.exists(metadata_file)) {
    metadata_df = read_tsv(metadata_file)
    
    N = metadata_df %>% nrow() # global variable
    
    # Generate a very simple table which can be used to convert long paths or their basenames to sample names
    metadata_translate = metadata_df %>% 
        select(sample, file_long = input_file_fasta) %>%
        mutate(file = basename(file_long))
    

    # Present the metadata in the report
    metadata_df %>%
        select(-index) %>% 
        datatable(class = 'cell-border stripe')
    
    
    
} else {
    stop(paste("The metadata file", metadata_file, "is not accessible.")) # Should stop the script completely
}

### Sections below
```

*Table `r tableno()`: Overview of the samples analysed in this run.*


### Report section overview

Here is an overview of number of result files that have been found for each analysis. A report section is only rendered if relevant result files are present for that analysis.

```{r switchboard, echo=FALSE, message=F, warning=F}

# Pull all globs and show which are done/presentable

# glob = list()

# glob$assembly_stats = Sys.glob(paste0(results_directory, "/assembly-stats/assembly-stats.tsv"))
# glob$prokka = Sys.glob(paste0(results_directory, "/samples/*/prokka/*.txt"))
# glob$busco = Sys.glob(paste0(results_directory, "/samples/*/busco/*_omesnatoehsnatoe_extract.tsv"))

# Each section of this report is rendered on the basis of the presence of relevant result files.
# In the table below, the globs, and expected number of globs are defined. 
section_definition_table = tribble(
    ~section, ~expectation, ~glob,
    "assembly_stats",   1, Sys.glob(paste0(results_directory, "/assembly-stats/assembly-stats.tsv")),
    "sequence_lengths", N, Sys.glob(paste0(results_directory, "/samples/*/sequence_lengths/*.tsv")),
    "prokka",           N, Sys.glob(paste0(results_directory, "/samples/*/prokka/*.txt")),
    "busco",            N, Sys.glob(paste0(results_directory, "/samples/*/busco/*.txt")),
    "roary",            1, Sys.glob(paste0(results_directory, "/samples/*/roray/*.txt")),

    ) %>%
    #group_by(section) %>%
    mutate(n_files = lengths(glob))


# This list is used out in the individual sections to access the correct files.
glob_list = section_definition_table %>%
    select(section, glob) %>%
    deframe() # Convert to list

# The render variable is finally used to toggle the rendering of each section in the report.
render = lapply(glob_list, function(x) {length(x) > 0})


# Present which analysis results will be rendered in the report
# glob %>%
#     lapply(length) %>%
#     as_tibble() %>%
#     pivot_longer(everything(), names_to = "section", values_to = "n_files") %>%
#     mutate(
#         decision = case_when(
#             n_files > 0 ~ paste("yes"),
#             TRUE ~ "no"),
#         results = paste0(decision, " (", n_files, ")" )
#     ) %>%
#     select(section, `results (files)` = results) %>%
#     custom_dt(dom = "t")

section_definition_table %>%
    mutate(
        render = case_when(
            #n_files > 0 ~ paste("yes"),
            n_files == expectation ~ "ðŸŸ¢ yes",
            n_files > 0 ~ "ðŸŸ¡ yes, partially",
            n_files == 0 ~ "ðŸ”´ no"),
        `n / expected` = paste0(n_files, " / ", expectation)
    ) %>%
    select(section, `n / expected`, render) %>%
    custom_dt(dom = "t", ordering = F)

# Define a variable that can be used to query whether each section of the report should be rendered


```





```{r child = paste0(report_scripts, "section_assembly_stats.rmd"), eval = render$assembly_stats}
```


```{r child = paste0(report_scripts, "section_sequence_lengths.rmd"), eval = render$sequence_lengths}
```


```{r child = paste0(report_scripts, "section_prokka.rmd"), eval = render$prokka}

```






